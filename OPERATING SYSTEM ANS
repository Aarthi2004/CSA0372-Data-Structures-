SET 1-1) PRODUCER  CONSUMER


#include<stdio.h>
#include<stdlib.h>
int mutex=1;
int full=0;
int empty=10,x=0;
void producer()
{
	--mutex;
	++full;
	--empty;
	x++;
	printf("\nproducer produces item %d",x);
	++mutex;
}
void consumer()
{
	--mutex;
	--full;
	++empty;
	x--;
	printf("\nconsumer consumes item %d",x);
	x--;
	++mutex;
}
int main()
{
	int n,i;
	printf("\n1.FOR PRODUCER\n2.FOR CONSUMER\n3.FOR EXIT");
	#pragma omp critical
	for(i=1;i>0;i++){
		printf("\nenter your choice:");
		scanf("%d",n);
		switch(n){
			case 1:
				if((mutex==1) && (empty!=0)){
					producer();
				}
				else
				printf("buffer is empty");
				break;
			case 2:
			    if((mutex==1 )&& (full!=0)){
			   	consumer();
				}	
				else
				printf("buffer is empty");
				break;
			case 3:
			    exit(0);
				break;	
					
		}
		
	}

}



set 1-2) SYSTEM CALL PARENT
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>

int main() {
   pid_t pid, ppid;

   pid = fork();
   if (pid == 0) {
      printf("Child process\n");
      printf("pid: %d\n", getpid());
      printf("ppid: %d\n", getppid());
   } else if (pid > 0) {
      printf("Parent process\n");
      printf("pid: %d\n", getpid());
      printf("ppid: %d\n", getppid());
   } else {
      printf("Failed to create a new process\n");
   }
   return 0;
}


set 1-3) SCAN ALGORITHM


#include<stdio.h>

int main()
{
    int n, head, seek=0, max, diff, d[100];
    printf("Enter the number of tracks in disk: ");
    scanf("%d", &n);
    printf("Enter position of head: ");
    scanf("%d", &head);
    printf("Enter elements in disk queue: ");
    for (int i=0; i<n; i++)
        scanf("%d", &d[i]);
    d[n]=head;
    n=n+1;
    for (int i=0; i<n; i++)
    {
        for (int j=i; j<n; j++)
        {
            if (d[i]>d[j])
            {
                diff=d[i]-d[j];
                d[i]=d[j];
                d[j]=diff+d[i];
            }
        }
    }
    max=d[n-1];
    for (int i=0; i<n; i++)
    {
        if (d[i]>head)
        {
            for (int j=i; j>=0; j--)
                seek=seek+abs(d[j+1]-d[j]);
            break;
        }
    }
    printf("\nTotal number of seek operations = %d\n", seek);
    return 0;
}



SET 1-4)  INDEXED FILE ALLOCATION

#include <stdio.h>
#define MAX_BLOCKS 30
int main() {
   int blocks[MAX_BLOCKS];
   int i, j;
   int index_block = 19;
   int block_count = 5;
   for (i = 0; i < MAX_BLOCKS; i++) {
      blocks[i] = -1;
   }
   blocks[index_block] = 9;
   blocks[index_block + 1] = 16;
   blocks[index_block + 2] = 1;
   blocks[index_block + 3] = 10;
   blocks[index_block + 4] = 25;
   printf("Indexed file allocation for file 'text1':\n");
   for (j = 0; j < block_count; j++) {
      printf("Block %d: %d\n", j, blocks[index_block + j]);
   }

   return 0;
}
 -----------------------------------------------------------------------------------------------------------------------

set 2-1) SJF

#include <stdio.h>
#include <stdlib.h>

#define MAX_PROCESSES 100

struct Process {
    int pid;
    int burst_time;
};

int compare(const void *a, const void *b) {
    return ((struct Process *)a)->burst_time - ((struct Process *)b)->burst_time;
}

int main() {
    int n, i;
    struct Process processes[MAX_PROCESSES];

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the burst time of each process:\n");
    for (i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        scanf("%d", &processes[i].burst_time);
    }

    qsort(processes, n, sizeof(struct Process), compare);

    int total_waiting_time = 0;
    int total_turnaround_time = 0;

    printf("\nProcess ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        int waiting_time = total_waiting_time;
        int turnaround_time = waiting_time + processes[i].burst_time;
 
        printf("%d\t\t%d\t\t%d\t\t%d\n", processes[i].pid, processes[i].burst_time, waiting_time, turnaround_time);

        total_waiting_time += processes[i].burst_time;
        total_turnaround_time += turnaround_time;
    }

    printf("\nAverage Waiting Time: %.2f\n", (float)total_waiting_time / n);
    printf("Average Turnaround Time: %.2f\n", (float)total_turnaround_time / n);

    return 0;
}


SET 2-2) SYSTEM CALL PARENT-ODD  CHILD EVEN

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#define MAX_NUM 100
int main() {
   int i, n;
   pid_t pid;
   pid = fork();
   if (pid == 0) {
      printf("Child process - Generating even numbers:\n");
      for (i = 2; i <= MAX_NUM; i += 2) {
         printf("%d\n", i);
      }
   } else if (pid > 0) {
      wait(NULL);
      printf("Parent process - Generating odd numbers:\n");
      for (i = 1; i <= MAX_NUM; i += 2) {
         printf("%d\n", i);
      }
   } else
   {
      printf("Failed to create a new process\n");
   }
   return 0;
}

set 2-3) C-SCAN

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100
#define MAX_CYLINDERS 5000

int requests[MAX_REQUESTS];

int compare(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

int main() {
    int n, i, head, seek_time = 0;

    printf("Enter the number of requests: ");
    scanf("%d", &n);

    printf("Enter the requests (cylinders):\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    printf("Enter the initial head position: ");
    scanf("%d", &head);

    qsort(requests, n, sizeof(int), compare);

    int left = 0, right = n - 1;
    while (left <= right && requests[left] < head) {
        left++;
    }

    while (left <= right) {
        seek_time += abs(requests[left] - head);
        head = requests[left];
        left++;
    }

    seek_time += MAX_CYLINDERS - head;
    head = 0;

    while (left <= n - 1) {
        seek_time += abs(requests[left] - head);
        head = requests[left];
        left++;
    }

    printf("\nTotal Seek Time: %d\n", seek_time);
    printf("Average Seek Time: %.2f\n", (float)seek_time / n);

    return 0;
}



SET 2-4) TWO LEVEL DIRECTORY SYSTEM

#include <stdio.h>
#include <string.h>
#define MAX_USERS 10
#define MAX_FILES_PER_USER 10
#define MAX_FILENAME_LENGTH 20
struct User {
   char username[MAX_FILENAME_LENGTH];
   int ufd[MAX_FILES_PER_USER];
};
struct Master {
   struct User users[MAX_USERS];
   int user_count;
};
struct Master master;
void init_master() {
   int i, j;
   master.user_count = 0;
   for (i = 0; i < MAX_USERS; i++) {
      memset(master.users[i].username, 0, MAX_FILENAME_LENGTH);
      for (j = 0; j < MAX_FILES_PER_USER; j++) {
         master.users[i].ufd[j] = -1;
      }
   }
}
void add_user(char *username) {
   int i;
   int index = master.user_count;
   strcpy(master.users[index].username, username);
   master.user_count++;
   printf("User %s added to the system\n", username);
   printf("User %s has the following UFD:\n", username);
   for (i = 0; i < MAX_FILES_PER_USER; i++) {
      printf("File %d: %d\n", i, master.users[index].ufd[i]);
   }
}
void list_users() {
   int i;
   printf("Master block contains the following users:\n");
   for (i = 0; i < master.user_count; i++) {
      printf("User %d: %s\n", i, master.users[i].username);
   }
}
int main() {
   init_master();
   add_user("user1");
   add_user("user2");
   add_user("user3");
   list_users();
   return 0;
}

----------------------------------------------------------------------------------------------------------------------


set 3-1) ROUND ROBIN

#include <stdio.h>
#include <stdlib.h>

#define MAX_PROCESSES 100

struct Process {
    int pid;
    int burst_time;
    int waiting_time;
    int turn_around_time;
    int remaining_time;
};

int main() {
    int n, i, j, time_quantum;
    struct Process processes[MAX_PROCESSES];

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the burst time of each process:\n");
    for (i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        scanf("%d", &processes[i].burst_time);
        processes[i].remaining_time = processes[i].burst_time;
    }

    printf("Enter the time quantum: ");
    scanf("%d", &time_quantum);

    int total_waiting_time = 0;
    int total_turnaround_time = 0;

    int time = 0;
    while (1) {
        int done = 1;
        for (i = 0; i < n; i++) {
            if (processes[i].remaining_time > 0) {
                done = 0;
                if (processes[i].remaining_time > time_quantum) {
                    time += time_quantum;
                    processes[i].remaining_time -= time_quantum;
                } else {
                    time += processes[i].remaining_time;
                    processes[i].waiting_time = time - processes[i].burst_time;
                    processes[i].turn_around_time = time;
                    processes[i].remaining_time = 0;
                }
            }
        }
        if (done) {
            break;
        }
    }

    printf("\nProcess ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        total_waiting_time += processes[i].waiting_time;
        total_turnaround_time += processes[i].turn_around_time;

        printf("%d\t\t%d\t\t%d\t\t%d\n", processes[i].pid, processes[i].burst_time, processes[i].waiting_time, processes[i].turn_around_time);
    }

    printf("\nAverage Waiting Time: %.2f\n", (float)total_waiting_time / n);
    printf("Average Turnaround Time: %.2f\n", (float)total_turnaround_time / n);

    return 0;
}



Set 3-2) SYSTEM CALL- CREATE READ DATA FRM USER  WRITE SAME CONTENT

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
int main() {
   int fd;
   char buffer[100];
   printf("Enter data to write to the file: ");
   fgets(buffer, 100, stdin);
   fd = open("sample.txt", O_RDWR | O_CREAT, 0644);
   if (fd == -1) {
      printf("Error opening file\n");
      return 1;
   }
   write(fd, buffer, strlen(buffer));
   close(fd);
   printf("Data written to the file successfully\n");
   return 0;
}

set 3-3)FCFS

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

int main() {
    int n, i, head, prev_head, total_distance = 0;
    int requests[MAX_REQUESTS];

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the initial head position: ");
    scanf("%d", &head);

    printf("Enter the requests, separated by spaces:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    for (i = 0; i < n; i++) {
        prev_head = head;
        head = requests[i];
        total_distance += abs(head - prev_head);
    }

    printf("\nTotal head movement (in cylinders): %d\n", total_distance);

    return 0;
}


set 3-4) FIRST FIT

#include <stdio.h>
#include <stdlib.h>

#define MAX_PROCESSES 100
#define MAX_MEMORY 1000

struct Process {
    int pid;
    int size;
    int memory_start;
};

int main() {
    int n, m, i, j, k;
    int memory[MAX_MEMORY];
    struct Process processes[MAX_PROCESSES];

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the size of each process:\n");
    for (i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        scanf("%d", &processes[i].size);
    }

    printf("Enter the size of memory: ");
    scanf("%d", &m);

    for (i = 0; i < m; i++) {
        memory[i] = 0;
    }

    for (i = 0; i < n; i++) {
        for (j = 0; j <= m - processes[i].size; j++) {
            int allocated = 1;
            for (k = j; k < j + processes[i].size; k++) {
                if (memory[k] != 0) {
                    allocated = 0;
                    break;
                }
            }
            if (allocated) {
                for (k = j; k < j + processes[i].size; k++) {
                    memory[k] = processes[i].pid;
                }
                processes[i].memory_start = j;
                break;
            }
        }
    }

    printf("\nProcess ID\tSize\tMemory Start\n");
    for (i = 0; i < n; i++) {
        printf("%d\t\t%d\t%d\n", processes[i].pid, processes[i].size, processes[i].memory_start);
    }

    return 0;
}


----------------------------------------------------------------------------------------------------------------------------------

Set 4-1) THREAD -SYNCHRONIZATION WITH SEMAPHORE

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define NUM_THREADS 5

sem_t semaphore;

void* do_something(void* thread_id) {
    sem_wait(&semaphore);
    printf("Thread %ld is entering critical section.\n", (long)thread_id);
    sleep(1);
    printf("Thread %ld is leaving critical section.\n", (long)thread_id);
    sem_post(&semaphore);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    pthread_t threads[NUM_THREADS];
    sem_init(&semaphore, 0, 1);
    long i;
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, do_something, (void*)i);
    }
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    sem_destroy(&semaphore);
    return 0;
}


set 4-2)CPU SCHEDULING PRIORITY ALGORITHM

#include <stdio.h>
#include <stdlib.h>

#define MAX_PROCESSES 10

struct process {
    int process_id;
    int burst_time;
    int priority;
    int waiting_time;
};

int compare_processes(const void* a, const void* b) {
    struct process* process_a = (struct process*)a;
    struct process* process_b = (struct process*)b;
    if (process_a->priority < process_b->priority) {
        return -1;
    } else if (process_a->priority > process_b->priority) {
        return 1;
    } else {
        return 0;
    }
}

int main() {
    struct process processes[MAX_PROCESSES];
    int num_processes, i, total_waiting_time = 0;
    float average_waiting_time;
    printf("Enter the number of processes: ");
    scanf("%d", &num_processes);
    for (i = 0; i < num_processes; i++) {
        printf("Enter the details of process %d: \n", i + 1);
        printf("Process ID: ");
        scanf("%d", &processes[i].process_id);
        printf("Burst Time: ");
        scanf("%d", &processes[i].burst_time);
        printf("Priority: ");
        scanf("%d", &processes[i].priority);
    }
    qsort(processes, num_processes, sizeof(struct process), compare_processes);
    for (i = 0; i < num_processes; i++) {
        if (i == 0) {
            processes[i].waiting_time = 0;
        } else {
            processes[i].waiting_time = processes[i - 1].burst_time + processes[i - 1].waiting_time;
        }
        total_waiting_time += processes[i].waiting_time;
    }
    average_waiting_time = (float)total_waiting_time / num_processes;
    printf("Processes executed in order: \n");
    for (i = 0; i < num_processes; i++) {
        printf("Process ID: %d, Burst Time: %d, Priority: %d, Waiting Time: %d\n",
               processes[i].process_id, processes[i].burst_time, processes[i].priority, processes[i].waiting_time);
    }
    printf("Average Waiting Time: %.2f\n", average_waiting_time);
    return 0;
}


set 4-3) SCAN


#include<stdio.h>

int main()
{
    int n, head, seek=0, max, diff, d[100];
    printf("Enter the number of tracks in disk: ");
    scanf("%d", &n);
    printf("Enter position of head: ");
    scanf("%d", &head);
    printf("Enter elements in disk queue: ");
    for (int i=0; i<n; i++)
        scanf("%d", &d[i]);
    d[n]=head;
    n=n+1;
    for (int i=0; i<n; i++)
    {
        for (int j=i; j<n; j++)
        {
            if (d[i]>d[j])
            {
                diff=d[i]-d[j];
                d[i]=d[j];
                d[j]=diff+d[i];
            }
        }
    }
    max=d[n-1];
    for (int i=0; i<n; i++)
    {
        if (d[i]>head)
        {
            for (int j=i; j>=0; j--)
                seek=seek+abs(d[j+1]-d[j]);
            break;
        }
    }
    printf("\nTotal number of seek operations = %d\n", seek);
    return 0;
}


set 4-4) PRODUCER CONSUMER


#include<stdio.h>
#include<stdlib.h>
int mutex=1;
int full=0;
int empty=10,x=0;
void producer()
{
	--mutex;
	++full;
	--empty;
	x++;
	printf("\nproducer produces item %d",x);
	++mutex;
}
void consumer()
{
	--mutex;
	--full;
	++empty;
	x--;
	printf("\nconsumer consumes item %d",x);
	x--;
	++mutex;
}
int main()
{
	int n,i;
	printf("\n1.FOR PRODUCER\n2.FOR CONSUMER\n3.FOR EXIT");
	#pragma omp critical
	for(i=1;i>0;i++){
		printf("\nenter your choice:");
		scanf("%d",n);
		switch(n){
			case 1:
				if((mutex==1) && (empty!=0)){
					producer();
				}
				else
				printf("buffer is empty");
				break;
			case 2:
			    if((mutex==1 )&& (full!=0)){
			   	consumer();
				}	
				else
				printf("buffer is empty");
				break;
			case 3:
			    exit(0);
				break;	
					
		}
		
	}

}

---------------------------------------------------------------------------------------------------------------------------------------------------------

set 5-1)FCFS


#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

int main() {
    int n, i, head, prev_head, total_distance = 0;
    int requests[MAX_REQUESTS];

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the initial head position: ");
    scanf("%d", &head);

    printf("Enter the requests, separated by spaces:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    for (i = 0; i < n; i++) {
        prev_head = head;
        head = requests[i];
        total_distance += abs(head - prev_head);
    }

    printf("\nTotal head movement (in cylinders): %d\n", total_distance);

    return 0;
}


set 5-2) THREAD ONE TH EVEN OTHER TH ODD


#include <stdio.h>
#include <pthread.h>

#define MAX_NUMBER 100

void* print_even_numbers(void* arg) {
    int i;
    for (i = 0; i <= MAX_NUMBER; i += 2) {
        printf("%d\n", i);
    }
    return NULL;
}

void* print_odd_numbers(void* arg) {
    int i;
    for (i = 1; i <= MAX_NUMBER; i += 2) {
        printf("%d\n", i);
    }
    return NULL;
}

int main() {
    pthread_t even_thread, odd_thread;
    pthread_create(&even_thread, NULL, print_even_numbers, NULL);
    pthread_create(&odd_thread, NULL, print_odd_numbers, NULL);
    pthread_join(even_thread, NULL);
    pthread_join(odd_thread, NULL);
    return 0;
}


set 5-3)n a new process enters a system,
 it must declare the maximum number of instances of each resource type it needs

#include<stdio.h>
#include<pthread.h>
#define MAX_RESOURCES 5

int available_resources = MAX_RESOURCES;
pthread_mutex_t mtx;

int decrease_count(int count)
{
    pthread_mutex_lock(&mtx);
    if (available_resources < count)
    {
        pthread_mutex_unlock(&mtx);
        return -1;
    }
    else
    {
        available_resources -= count;
        pthread_mutex_unlock(&mtx);
        return 0;
    }
}

int increase_count(int count)
{
    pthread_mutex_lock(&mtx);
    available_resources += count;
    pthread_mutex_unlock(&mtx);
    return 0;
}

void *process_function(void *arg)
{
    int count = (int)arg;
    if (decrease_count(count) == 0)
    {
        printf("Allocated %d resources\n", count);
        sleep(5);
        increase_count(count);
        printf("Released %d resources\n", count);
    }
    else
    {
        printf("Requested %d resources is more than available resources\n", count);
    }
    pthread_exit(NULL);
}

int main()
{
    int i, num_threads, count;
    pthread_t threads[100];

    printf("Enter number of threads: ");
    scanf("%d", &num_threads);
    for (i = 0; i < num_threads; i++)
    {
        printf("Enter resource count for thread %d: ", i + 1);
        scanf("%d", &count);
        pthread_create(&threads[i], NULL, process_function, (void *)count);
    }
    for (i = 0; i < num_threads; i++)
    {
        pthread_join(threads[i], NULL);
    }
    return 0;
}


set 5-4) INDEXED FILE ALLOCATION


#include <stdio.h>
#define MAX_BLOCKS 30
int main() {
   int blocks[MAX_BLOCKS];
   int i, j;
   int index_block = 19;
   int block_count = 5;
   for (i = 0; i < MAX_BLOCKS; i++) {
      blocks[i] = -1;
   }
   blocks[index_block] = 9;
   blocks[index_block + 1] = 16;
   blocks[index_block + 2] = 1;
   blocks[index_block + 3] = 10;
   blocks[index_block + 4] = 25;
   printf("Indexed file allocation for file 'text1':\n");
   for (j = 0; j < block_count; j++) {
      printf("Block %d: %d\n", j, blocks[index_block + j]);
   }

   return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------

set 6-1)FCFS

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

int main() {
    int n, i, head, prev_head, total_distance = 0;
    int requests[MAX_REQUESTS];

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the initial head position: ");
    scanf("%d", &head);

    printf("Enter the requests, separated by spaces:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    for (i = 0; i < n; i++) {
        prev_head = head;
        head = requests[i];
        total_distance += abs(head - prev_head);
    }

    printf("\nTotal head movement (in cylinders): %d\n", total_distance);

    return 0;
}


set 6-2)FIFO

#include<stdio.h>
#define MAX_PAGES 100

int pages[MAX_PAGES];
int page_faults = 0;

void page_replacement(int num_pages, int num_frames)
{
    int frames[num_frames];
    int i, j, k, flag;
    for (i = 0; i < num_frames; i++)
        frames[i] = -1;
    for (i = 0; i < num_pages; i++)
    {
        flag = 0;
        for (j = 0; j < num_frames; j++)
        {
            if (frames[j] == pages[i])
            {
                flag = 1;
                break;
            }
        }
        if (flag == 0)
        {
            for (k = 0; k < num_frames - 1; k++)
                frames[k] = frames[k + 1];
            frames[num_frames - 1] = pages[i];
            page_faults++;
        }
    }
    printf("Total page faults: %d\n", page_faults);
}

int main()
{
    int num_pages, num_frames, i;
    printf("Enter number of pages: ");
    scanf("%d", &num_pages);
    printf("Enter number of frames: ");
    scanf("%d", &num_frames);
    printf("Enter reference string: ");
    for (i = 0; i < num_pages; i++)
        scanf("%d", &pages[i]);
    page_replacement(num_pages, num_frames);
    return 0;
}


set 6-3)SINGLE LEVEL DIRECTORY FILE ORGANIZATION

#include<stdio.h>
#include<string.h>
#define MAX_FILES 20

struct File
{
    char name[20];
    int size;
};

struct Directory
{
    struct File files[MAX_FILES];
    int num_files;
};

void create_file(struct Directory *dir, char *name, int size)
{
    strcpy(dir->files[dir->num_files].name, name);
    dir->files[dir->num_files].size = size;
    dir->num_files++;
}

void delete_file(struct Directory *dir, char *name)
{
    int i, index = -1;
    for (i = 0; i < dir->num_files; i++)
    {
        if (strcmp(dir->files[i].name, name) == 0)
        {
            index = i;
            break;
        }
    }
    if (index == -1)
    {
        printf("File not found\n");
        return;
    }
    for (i = index; i < dir->num_files - 1; i++)
        dir->files[i] = dir->files[i + 1];
    dir->num_files--;
}

void display_directory(struct Directory *dir)
{
    int i;
    printf("Files in directory:\n");
    for (i = 0; i < dir->num_files; i++)
        printf("%s\t%d\n", dir->files[i].name, dir->files[i].size);
}

int main()
{
    struct Directory dir;
    dir.num_files = 0;
    create_file(&dir, "file1", 100);
    create_file(&dir, "file2", 200);
    display_directory(&dir);
    delete_file(&dir, "file1");
    display_directory(&dir);
    return 0;
}


set 6-4) PRINT NATURAL NUBER USING TWO THREAD

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

#define N 20

void* print_numbers(void *arg)
{
    int i;
    for (i = *((int*)arg); i <= N; i += 2)
    {
        printf("%d\n", i);
        sleep(1);
    }
    return NULL;
}

int main()
{
    pthread_t first_thread, second_thread;
    int first_thread_arg = 1, second_thread_arg = 2;
    pthread_create(&first_thread, NULL, &print_numbers, &first_thread_arg);
    pthread_create(&second_thread, NULL, &print_numbers, &second_thread_arg);
    pthread_join(first_thread, NULL);
    pthread_join(second_thread, NULL);
    return 0;
}

----------------------------------------------------------------------------------------------------------------------------------------------

set 7-1) PAGE REPLACEMENT-current least recently used element is replaced

#include<stdio.h> 

// Function to find the page to be replaced 
int replaceLRU(int time[], int n){ 
    int i, minimum = time[0], pos = 0; 
  
    for(i = 1; i < n; ++i){ 
        if(time[i] < minimum){ 
            minimum = time[i]; 
            pos = i; 
        } 
    } 
  
    return pos; 
} 

int main(){ 
    int n, m, pages[25], counter = 0, time[25], flag, pos, i; 
  
    printf("Enter number of pages: "); 
    scanf("%d", &n); 
    printf("Enter number of frames: "); 
    scanf("%d", &m); 
  
    printf("Enter reference string: "); 
  
    for(i = 0; i < n; ++i){ 
        scanf("%d", &pages[i]); 
    } 
  
    // Initially all entries are -1 
    for(i = 0; i < m; ++i){ 
        time[i] = -1; 
    } 
  
    for(i = 0; i < n; ++i){ 
        flag = 0; 
        for(int j = 0; j < m; ++j){ 
            if(pages[i] == time[j]){ 
                counter++; 
                time[j] = counter; 
                flag = 1; 
                break; 
            } 
        } 
  
        if(flag == 0){ 
            pos = replaceLRU(time, m); 
            time[pos] = counter; 
            counter++; 
        } 
  
        printf("\n"); 
        for(int j = 0; j < m; ++j){ 
            printf("%d\t", time[j]); 
        } 
    } 
  
    return 0; 
} 


set 7-2)DINNING PHILOSOPHER


#include <stdio.h>
#include <semaphore.h>
#include <pthread.h>
#define N 5 
sem_t chopsticks[N];
void *philosopher(void *num) {
    int i = *((int *)num);
    printf("Philosopher %d is thinking\n", i+1);
    while (1) {
        printf("Philosopher %d is hungry\n", i+1);
        sem_wait(&chopsticks[i]);
        printf("Philosopher %d picked up left chopstick %d\n", i+1, i+1);
        sem_wait(&chopsticks[(i+1)%N]);
        printf("Philosopher %d picked up right chopstick %d\n", i+1, (i+1)%N+1);
        printf("Philosopher %d is eating\n", i+1);
        sleep(3);
        sem_post(&chopsticks[i]);
        printf("Philosopher %d released left chopstick %d\n", i+1, i+1);
        sem_post(&chopsticks[(i+1)%N]);
        printf("Philosopher %d released right chopstick %d\n", i+1, (i+1)%N+1);
        printf("Philosopher %d is thinking\n", i+1);
        sleep(3);
    }
}
int main() {
    int i;
    pthread_t thread_id[N];
    int philosophers[N];
    for (i = 0; i < N; i++) {
        sem_init(&chopsticks[i], 0, 1);
    }

    for (i = 0; i < N; i++) {
        philosophers[i] = i;
        pthread_create(&thread_id[i], NULL, philosopher, &philosophers[i]);
    }

    for (i = 0; i < N; i++) {
        pthread_join(thread_id[i], NULL);
    }

    for (i = 0; i < N; i++) {
        sem_destroy(&chopsticks[i]);
    }
    return 0;
}


set 7-3)BEST FIT

#include<stdio.h>
#include<stdbool.h>

#define MAX 100

int fragments[MAX];
int main()
{
    int blocks,process,block_size[MAX],process_size[MAX],allocation[MAX];
    int i,j;
    printf("Enter number of blocks: ");
    scanf("%d",&blocks);
    printf("Enter block size:\n");
    for(i=0;i<blocks;i++)
    {
        scanf("%d",&block_size[i]);
    }
    printf("Enter number of processes: ");
    scanf("%d",&process);
    printf("Enter process size:\n");
    for(i=0;i<process;i++)
    {
        scanf("%d",&process_size[i]);
    }
    for(i=0;i<process;i++)
    {
        int best_fit=MAX;
        int best_index=-1;
        for(j=0;j<blocks;j++)
        {
            if(block_size[j]>=process_size[i])
            {
                if(block_size[j]-process_size[i]<best_fit)
                {
                    best_fit=block_size[j]-process_size[i];
                    best_index=j;
                }
            }
        }
        if(best_index!=-1)
        {
            allocation[i]=best_index;
            fragments[best_index]=process_size[i];
            block_size[best_index]-=process_size[i];
        }
        else
        {
            allocation[i]=-1;
        }
    }
    printf("\nProcess_No\tProcess_Size\tBlock_No\n");
    for(i=0;i<process;i++)
    {
        printf("%d\t\t%d\t\t",i+1,process_size[i]);
        if(allocation[i]!=-1)
        {
            printf("%d\n",allocation[i]+1);
        }
        else
        {
            printf("Not Allocated\n");
        }
    }
    return 0;
}


set 7-4)SYNCHRONIZATION WITH SEMAPHORE


#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>

#define NUM_THREADS 5

sem_t semaphore;

void* do_something(void* thread_id) {
    sem_wait(&semaphore);
    printf("Thread %ld is entering critical section.\n", (long)thread_id);
    sleep(1);
    printf("Thread %ld is leaving critical section.\n", (long)thread_id);
    sem_post(&semaphore);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    pthread_t threads[NUM_THREADS];
    sem_init(&semaphore, 0, 1);
    long i;
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, do_something, (void*)i);
    }
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    sem_destroy(&semaphore);
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------
set 8-1)THREAD -N NATURAL NUM USING TWO THREAD

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

#define N 20

void* print_numbers(void *arg)
{
    int i;
    for (i = *((int*)arg); i <= N; i += 2)
    {
        printf("%d\n", i);
        sleep(1);
    }
    return NULL;
}

int main()
{
    pthread_t first_thread, second_thread;
    int first_thread_arg = 1, second_thread_arg = 2;
    pthread_create(&first_thread, NULL, &print_numbers, &first_thread_arg);
    pthread_create(&second_thread, NULL, &print_numbers, &second_thread_arg);
    pthread_join(first_thread, NULL);
    pthread_join(second_thread, NULL);
    return 0;
}

set 8-2)n a new process enters a system,
 it must declare the maximum number of instances of each resource type it needs


#include<stdio.h>
#include<pthread.h>
#define MAX_RESOURCES 5

int available_resources = MAX_RESOURCES;
pthread_mutex_t mtx;

int decrease_count(int count)
{
    pthread_mutex_lock(&mtx);
    if (available_resources < count)
    {
        pthread_mutex_unlock(&mtx);
        return -1;
    }
    else
    {
        available_resources -= count;
        pthread_mutex_unlock(&mtx);
        return 0;
    }
}

int increase_count(int count)
{
    pthread_mutex_lock(&mtx);
    available_resources += count;
    pthread_mutex_unlock(&mtx);
    return 0;
}

void *process_function(void *arg)
{
    int count = (int)arg;
    if (decrease_count(count) == 0)
    {
        printf("Allocated %d resources\n", count);
        sleep(5);
        increase_count(count);
        printf("Released %d resources\n", count);
    }
    else
    {
        printf("Requested %d resources is more than available resources\n", count);
    }
    pthread_exit(NULL);
}

int main()
{
    int i, num_threads, count;
    pthread_t threads[100];

    printf("Enter number of threads: ");
    scanf("%d", &num_threads);
    for (i = 0; i < num_threads; i++)
    {
        printf("Enter resource count for thread %d: ", i + 1);
        scanf("%d", &count);
        pthread_create(&threads[i], NULL, process_function, (void *)count);
    }
    for (i = 0; i < num_threads; i++)
    {
        pthread_join(threads[i], NULL);
    }
    return 0;
}


set 8-3)PAGE CALLED-PAGE REPLACEMENT METHOD

#include <stdio.h>
#include <stdbool.h>

#define MAX_PAGE_FRAME 100
#define MAX_PAGE_REFERENCE 200

int page_frames[MAX_PAGE_FRAME];
int future_time[MAX_PAGE_FRAME];
int page_reference[MAX_PAGE_REFERENCE];
int num_page_frames;
int num_page_reference;
int page_faults;

bool is_page_in_frame(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] == page) {
            return true;
        }
    }
    return false;
}

void update_future_time(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] != page) {
            future_time[i]--;
        }
    }
}

int get_frame_to_replace() {
    int frame = 0;
    int max_time = 0;
    for (int i = 0; i < num_page_frames; i++) {
        if (future_time[i] > max_time) {
            max_time = future_time[i];
            frame = i;
        }
    }
    return frame;
}

void simulate_page_replacement() {
    for (int i = 0; i < num_page_reference; i++) {
        if (!is_page_in_frame(page_reference[i])) {
            page_faults++;
            if (page_frames[0] == -1) {
                for (int j = 0; j < num_page_frames; j++) {
                    page_frames[j] = page_reference[i];
                    future_time[j] = num_page_reference - i;
                }
            } else {
                int frame = get_frame_to_replace();
                page_frames[frame] = page_reference[i];
                future_time[frame] = num_page_reference - i;
            }
        }
        update_future_time(page_reference[i]);
    }
}

int main() {
    printf("Enter number of page frames: ");
    scanf("%d", &num_page_frames);
    printf("Enter number of page references: ");
    scanf("%d", &num_page_reference);
    printf("Enter page reference string: ");
    for (int i = 0; i < num_page_reference; i++) {
        scanf("%d", &page_reference[i]);
    }
    for (int i = 0; i < num_page_frames; i++) {
        page_frames[i] = -1;
        future_time[i] = 0;
    }
    simulate_page_replacement();
    printf("Number of page faults: %d\n", page_faults);
    return 0;
}


set 8-4)SJF

#include <stdio.h>
#include <stdlib.h>

#define MAX_PROCESSES 100

struct Process {
    int pid;
    int burst_time;
};

int compare(const void *a, const void *b) {
    return ((struct Process *)a)->burst_time - ((struct Process *)b)->burst_time;
}

int main() {
    int n, i;
    struct Process processes[MAX_PROCESSES];

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the burst time of each process:\n");
    for (i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        scanf("%d", &processes[i].burst_time);
    }

    qsort(processes, n, sizeof(struct Process), compare);

    int total_waiting_time = 0;
    int total_turnaround_time = 0;

    printf("\nProcess ID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        int waiting_time = total_waiting_time;
        int turnaround_time = waiting_time + processes[i].burst_time;
 
        printf("%d\t\t%d\t\t%d\t\t%d\n", processes[i].pid, processes[i].burst_time, waiting_time, turnaround_time);

        total_waiting_time += processes[i].burst_time;
        total_turnaround_time += turnaround_time;
    }

    printf("\nAverage Waiting Time: %.2f\n", (float)total_waiting_time / n);
    printf("Average Turnaround Time: %.2f\n", (float)total_turnaround_time / n);

    return 0;
}
---------------------------------------------------------------------------------------------------------------------------------------------
set 9-1)DEADLOCK

#include <pthread.h> 
#include <stdio.h> 
#include <unistd.h> 
  
pthread_mutex_t first_mutex = PTHREAD_MUTEX_INITIALIZER; 
pthread_mutex_t second_mutex = PTHREAD_MUTEX_INITIALIZER; 
  
void *thread_one(void *arg) 
{ 
    pthread_mutex_lock(&first_mutex); 
    printf("Thread 1 has acquired lock 1\n"); 
    sleep(2); 
  
    pthread_mutex_lock(&second_mutex); 
    printf("Thread 1 has acquired lock 2\n"); 
  
    pthread_mutex_unlock(&second_mutex); 
    pthread_mutex_unlock(&first_mutex); 
    return NULL; 
} 
  
void *thread_two(void *arg) 
{ 
    pthread_mutex_lock(&second_mutex); 
    printf("Thread 2 has acquired lock 2\n"); 
    sleep(2); 
  
    pthread_mutex_lock(&first_mutex); 
    printf("Thread 2 has acquired lock 1\n"); 
  
    pthread_mutex_unlock(&first_mutex); 
    pthread_mutex_unlock(&second_mutex); 
    return NULL; 
} 
  
int main() 
{ 
    pthread_t t1, t2; 
    pthread_create(&t1, NULL, thread_one, NULL); 
    pthread_create(&t2, NULL, thread_two, NULL); 
  
    pthread_join(t1, NULL); 
    pthread_join(t2, NULL); 
  
    return 0; 
} 




set 9-2)PAGE CALLED-PAGE REPLACEMENT METHOD

#include <stdio.h>
#include <stdbool.h>

#define MAX_PAGE_FRAME 100
#define MAX_PAGE_REFERENCE 200

int page_frames[MAX_PAGE_FRAME];
int future_time[MAX_PAGE_FRAME];
int page_reference[MAX_PAGE_REFERENCE];
int num_page_frames;
int num_page_reference;
int page_faults;

bool is_page_in_frame(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] == page) {
            return true;
        }
    }
    return false;
}

void update_future_time(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] != page) {
            future_time[i]--;
        }
    }
}

int get_frame_to_replace() {
    int frame = 0;
    int max_time = 0;
    for (int i = 0; i < num_page_frames; i++) {
        if (future_time[i] > max_time) {
            max_time = future_time[i];
            frame = i;
        }
    }
    return frame;
}

void simulate_page_replacement() {
    for (int i = 0; i < num_page_reference; i++) {
        if (!is_page_in_frame(page_reference[i])) {
            page_faults++;
            if (page_frames[0] == -1) {
                for (int j = 0; j < num_page_frames; j++) {
                    page_frames[j] = page_reference[i];
                    future_time[j] = num_page_reference - i;
                }
            } else {
                int frame = get_frame_to_replace();
                page_frames[frame] = page_reference[i];
                future_time[frame] = num_page_reference - i;
            }
        }
        update_future_time(page_reference[i]);
    }
}

int main() {
    printf("Enter number of page frames: ");
    scanf("%d", &num_page_frames);
    printf("Enter number of page references: ");
    scanf("%d", &num_page_reference);
    printf("Enter page reference string: ");
    for (int i = 0; i < num_page_reference; i++) {
        scanf("%d", &page_reference[i]);
    }
    for (int i = 0; i < num_page_frames; i++) {
        page_frames[i] = -1;
        future_time[i] = 0;
    }
    simulate_page_replacement();
    printf("Number of page faults: %d\n", page_faults);
    return 0;
}


set 9-4)SYSTEM CALL-CREATE FILE/READ/WRITE

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
int main() {
   int fd;
   char buffer[100];
   printf("Enter data to write to the file: ");
   fgets(buffer, 100, stdin);
   fd = open("sample.txt", O_RDWR | O_CREAT, 0644);
   if (fd == -1) {
      printf("Error opening file\n");
      return 1;
   }
   write(fd, buffer, strlen(buffer));
   close(fd);
   printf("Data written to the file successfully\n");
   return 0;
}
----------------------------------------------------------------------------------------------------------------------------------
set 10-1) WORST FIT

#include <stdio.h>
#include <stdlib.h>

#define MAX_BLOCKS 100
#define MAX_MEMORY 1000

int memory[MAX_MEMORY];
int block_size[MAX_BLOCKS];

void worst_fit_allocate(int process_size) {
  int i, selected_block = -1, max_size = -1;
  for (i = 0; i < MAX_BLOCKS; i++) {
    if (block_size[i] >= process_size && block_size[i] > max_size) {
      selected_block = i;
      max_size = block_size[i];
    }
  }
  if (selected_block == -1) {
    printf("Cannot allocate memory, no suitable block found\n");
    return;
  }
  block_size[selected_block] -= process_size;
  printf("Allocated block %d of size %d for process of size %d\n", selected_block, max_size, process_size);
}

int main() {
  int i;
  for (i = 0; i < MAX_BLOCKS; i++) {
    block_size[i] = rand() % MAX_MEMORY;
  }
  worst_fit_allocate(50);
  worst_fit_allocate(200);
  worst_fit_allocate(300);
  worst_fit_allocate(400);
  return 0;
}

set 10-2)SEQUENTIAL FILE ALLOCATION

#include <stdio.h>
#include <string.h>

#define MAX_FILES 100
#define MAX_BLOCKS 1000

struct File {
  char name[20];
  int start_block;
  int size;
};

struct File file_table[MAX_FILES];
int free_block_list[MAX_BLOCKS];
int current_block = 0;

void allocate_file(char *file_name, int file_size) {
  strcpy(file_table[current_block].name, file_name);
  file_table[current_block].start_block = current_block;
  file_table[current_block].size = file_size;
  current_block += file_size;
  printf("Allocated file %s at block %d of size %d\n", file_name, file_table[current_block].start_block, file_size);
}

int main() {
  allocate_file("file1", 50);
  allocate_file("file2", 100);
  allocate_file("file3", 75);
  return 0;
}


set 10-3)PAGE CALLED-PAGE REPLACEMENT METHOD


#include <stdio.h>
#include <stdbool.h>

#define MAX_PAGE_FRAME 100
#define MAX_PAGE_REFERENCE 200

int page_frames[MAX_PAGE_FRA
ME];
int future_time[MAX_PAGE_FRAME];
int page_reference[MAX_PAGE_REFERENCE];
int num_page_frames;
int num_page_reference;
int page_faults;

bool is_page_in_frame(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] == page) {
            return true;
        }
    }
    return false;
}

void update_future_time(int page) {
    for (int i = 0; i < num_page_frames; i++) {
        if (page_frames[i] != page) {
            future_time[i]--;
        }
    }
}

int get_frame_to_replace() {
    int frame = 0;
    int max_time = 0;
    for (int i = 0; i < num_page_frames; i++) {
        if (future_time[i] > max_time) {
            max_time = future_time[i];
            frame = i;
        }
    }
    return frame;
}

void simulate_page_replacement() {
    for (int i = 0; i < num_page_reference; i++) {
        if (!is_page_in_frame(page_reference[i])) {
            page_faults++;
            if (page_frames[0] == -1) {
                for (int j = 0; j < num_page_frames; j++) {
                    page_frames[j] = page_reference[i];
                    future_time[j] = num_page_reference - i;
                }
            } else {
                int frame = get_frame_to_replace();
                page_frames[frame] = page_reference[i];
                future_time[frame] = num_page_reference - i;
            }
        }
        update_future_time(page_reference[i]);
    }
}

int main() {
    printf("Enter number of page frames: ");
    scanf("%d", &num_page_frames);
    printf("Enter number of page references: ");
    scanf("%d", &num_page_reference);
    printf("Enter page reference string: ");
    for (int i = 0; i < num_page_reference; i++) {
        scanf("%d", &page_reference[i]);
    }
    for (int i = 0; i < num_page_frames; i++) {
        page_frames[i] = -1;
        future_time[i] = 0;
    }
    simulate_page_replacement();
    printf("Number of page faults: %d\n", page_faults);
    return 0;
}



set 10-4)FCFS

#include <stdio.h>
#include <stdlib.h>

#define MAX_REQUESTS 100

int main() {
    int n, i, head, prev_head, total_distance = 0;
    int requests[MAX_REQUESTS];

    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    printf("Enter the initial head position: ");
    scanf("%d", &head);

    printf("Enter the requests, separated by spaces:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &requests[i]);
    }

    for (i = 0; i < n; i++) {
        prev_head = head;
        head = requests[i];
        total_distance += abs(head - prev_head);
    }

    printf("\nTotal head movement (in cylinders): %d\n", total_distance);

    return 0;
}
